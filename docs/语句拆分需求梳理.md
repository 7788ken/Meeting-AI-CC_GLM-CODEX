# 语句拆分需求梳理与差距分析

> 目标：明确“语句拆分”（旧称“语义分段”）的实际实现与用户期望之间的偏差，作为后续重构依据。

## 1. 需求摘要（来自用户描述，已澄清）

- 在 meeting 页面中的“语句拆分”栏目，数据顺序倒置：新内容应在最上。
- 逻辑需重构：从数据库表 `transcript_events` 按窗口值（配置在 `.env`）取上下文，发送给语句拆分服务（GLM4.6flash），结果写入数据库表 `transcript_events_segments`。
- 核心链路：触发时取“上一句 A + 当前上下文 B”，由 LLM 推理下一句 C 并落库；再次触发用 C + B1 推理 D，循环生成，前端可看到完整对话。

## 2. 当前实现概览（事实）

### 2.1 现有模块与职责

- 语句拆分（当前唯一链路）：`backend/src/modules/transcript-event-segmentation/`
  - 核心：上一句 A + 当前上下文 B → 推理下一句 C，落库到 `transcript_events_segments`，循环生成。
  - 窗口：从 `transcript_events` 取尾部 N 条事件（配置 `CHUNK_SIZE`）。
- 原文事件流：`backend/src/modules/transcript-stream/`
  - 数据源为 `transcript_events`，提供窗口查询与快照。

### 2.2 当前处理流程（简化）

1. 从 `transcript_events` 取尾部窗口（`CHUNK_SIZE`）作为上下文 B。
2. 读取本会话上一句已生成内容 A（来自 `transcript_events_segments` 的最后一条）。
3. 调用 GLM 推理下一句 C，落库新记录到 `transcript_events_segments`。
4. 后续触发重复 1-3（A=C，B 也随事件增长更新）。

## 3. 与期望的关键差距

已按需求对齐：语句拆分以 `transcript_events_segments` 为唯一落库与前端展示来源，并采用“上一句 + 当前上下文 → 下一句”的循环生成方式。

## 4. “顺序倒置”问题初判

- `getSessionAnalysis` 已按 `startEventIndex/endEventIndex` 升序返回（后端无倒序）。
- 若前端显示“新在上”，更可能来自：
  - 前端排序/渲染逻辑；
  - 查询无排序导致的不稳定顺序；
  - 使用 `createdAt` 倒序拉取。
- meeting 页面“语句拆分”现使用 `TranscriptEventSegmentsPanel` 渲染 `transcript_events_segments`；按 `sequence` 倒序展示，满足“新在上”。

## 5. 需澄清的关键问题

1. `CHUNK_SIZE`（窗口 N）在不同会议长度/说话密度下的推荐取值区间？
2. “上一句 A”是否允许在 ASR 回滚（同 eventIndex 更新）时重算与回滚？

## 6. 结论

语句拆分链路已收敛为单一路径：从 `transcript_events` 取窗口上下文，结合上一句生成下一句，并落库到 `transcript_events_segments` 供前端展示。

## 7. 已落地改动（本次）

- 前端：meeting 页“语句拆分”改为展示 `transcript_events_segments` 的结果，新内容按 `sequence` 倒序显示。
- 后端：新增 `transcript-event-segmentation` 模块，基于 `transcript_events` 窗口 + 上一句内容生成下一句并落库到 `transcript_events_segments`。
- 通道：新增 WS 消息 `transcript_event_segment_upsert` 与快照接口 `GET /transcript-event-segmentation/session/:sessionId`。
