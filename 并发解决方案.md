# 并发解决方案（审阅与优化）

## 1. 背景与目标

当前系统已引入 GLM 多桶限流与会话级触发合并，但在多会话、多会议并行场景下仍会出现高并发争抢与 429。需要在不牺牲实时体验的前提下，提升并发吞吐与稳定性。

目标：
- 支持多会话并行且公平调度。
- 对 GLM 429 具备弹性降载与自恢复能力。
- 可配置、可观测、可逐步演进。

非目标：
- 不在本阶段引入跨服务强一致性或全局任务编排平台。
- 不做大规模架构重写，保持现有模块边界。

关键约束：
- 实时体验优先，允许在秒级粒度做“最新任务覆盖”。
- 任务类型之间隔离（ASR/拆分/翻译/分析各自限流）。

## 2. 现状审阅（基于代码事实）

关键事实：
- 语句拆分/分析/翻译/ASR 已拆分多桶限流（全局 + 模块桶）。
  - `backend/src/common/llm/glm-rate-limiter.ts`
  - 模块调用绑定桶：ASR/拆分/翻译/分析客户端。
- 语句拆分触发来自事件流与定时器，之前存在冷却期跳过调用；当前改为排队等待。
  - `backend/src/main.ts` 的调度逻辑
  - `backend/src/modules/transcript-event-segmentation/transcript-event-segmentation.service.ts`
- 当前限流模型为“桶内顺序队列 + 最小间隔 + 冷却”，桶间无会话公平性。

痛点：
- 多会话同时活跃时，桶内队列按到达顺序处理，容易出现会话间饥饿或长尾延迟。
- 上游 429 时整体抖动，缺少“会话级最新任务合并”。
- APIKey 单一，账号级限额导致整体吞吐受限。

关键问题归因：
- “桶内队列”顺序意味着高频会话可能长时间占用配额。
- 任务“可替代性”（例如最新窗口可以覆盖旧窗口）没有被利用。

## 3. 优化方案总览

分两层解决：
1) 会话级公平调度（优先）
2) 核心任务池/进程池（中长期）

### 3.1 可拓展架构补充清单（面向未来负载）

目标：在不引入复杂平台的前提下，为后续扩展留出清晰接口与可演进边界。

能力清单（按优先级）：
- 资源隔离：按 `tenantId/sessionId/taskType` 三维配额，避免单一会话/租户占满全局配额。
- Backpressure：在入口层统一执行“新任务覆盖旧任务 + 过期丢弃”，避免下游堆积。
- 自适应并发：根据 429 频率与延迟动态调整并发/最小间隔（上行收敛，下行平滑）。
- 多 Key/多 Provider：APIKey 池化与熔断，必要时引入备选模型提供商，避免单点限额。
- 任务标准化：统一任务信封（`taskId/sessionId/taskType/revisionId/windowRange/priority/deadline`），支撑未来队列与幂等处理。
- 配置中心与灰度：将桶配置、权重、超时、丢弃策略纳入配置，可灰度发布与回滚。

任务优先级（全局争抢时）：
- 权重：ASR > 拆分/针对性分析 > 翻译 > 全文分析。
- 作用点：仅在“全局桶/全局并发”成为瓶颈时生效，模块桶内仍按会话公平调度。

权重数值建议（可配置）：
- ASR = 4
- 拆分/针对性分析 = 3
- 翻译 = 2
- 全文分析 = 1

实现细节（保留 KISS 版本）：
- 方案 B（加权轮询）：维护 `tokenBucket[taskType]`，每轮按权重补充 tokens，取出首个有 token 的任务。

冲突处理与层级调度：
- 全局层：按任务类型权重分配调度机会（只在全局瓶颈时生效）。
- 模块层：同类型内做会话公平（Round-Robin + 最新覆盖）。
- 防饥饿约束：每轮至少给低权重类型保留 1 个 token，或设置最大等待时间触发强制放行。

## 4. 方案一：会话级公平调度（推荐优先实施）

思路：
- 按模块桶 + 会话队列，桶内对会话做 Round-Robin；每个会话只保留“最新待处理任务”。
- 避免积压过时窗口，同时保证多会话公平性。

实现要点：
- 为分段/分析类任务建立 `sessionPending`（按模块桶隔离）：
  - key = sessionId
  - value = 最新任务上下文（例如 latest revision/window）
- 调度器从 `sessionPending` 轮询出队，将任务交给 `GlmRateLimiter`。
- 同会话有新任务时覆盖旧任务（只保留最新）。

优点：
- 资源利用更高，避免长队列。
- 公平性强，多会话并行更稳定。

风险：
- 实现复杂度上升，需要明确“任务最新定义”。

细化设计（KISS 版本）：
- 术语：
  - “最新任务”：同 sessionId 下，按 `revisionId` 或 `windowEndTs` 最大者。
- 数据结构：
  - `sessionPending: Map<sessionId, TaskCtx>`
  - `sessionQueue: Array<sessionId>`（仅存活跃会话）
- 调度算法（伪码）：
  - 任务到达：`sessionPending[sessionId] = task`；若未在 `sessionQueue` 中，则追加。
  - 出队：从 `sessionQueue` 头取 sessionId，读取最新 task；执行后若该 session 仍有更新则重新入队，否则移除。

边界处理：
- 任务过期：超过 `maxStalenessMs` 直接丢弃。
- 会话无更新：不重新入队，避免空转。

验收标准：
- 并发会话数 > 3 时，单会话 P95 延迟不超过当前 1.5x。
- 429 发生率下降，且单会话不会长期饥饿。

## 5. 方案二：核心任务池/进程池

思路：
- 将拆分/分析任务移入队列系统（Redis + worker），主进程负责实时流与分发。

实现要点：
- 后端主进程：提交任务到队列，立即返回。
- Worker：执行 GLM 调用与持久化。
- 支持并发 worker 数配置与动态扩缩。
- 统一幂等键（`taskId` 或 `sessionId+revisionId`）与去重逻辑，避免重复写入。
- 失败重试采用指数退避 + 抖动，超限进入 DLQ 供回放排查。
- 任务超时与 deadline 到期强制取消，保护系统可用性。

收益：
- 提升吞吐并增强故障隔离。

## 6. 推荐落地路径（分阶段）

阶段 1（短期，1-2 天）：会话级公平调度
- 在“语句拆分”上引入 session 级合并队列。
- 删除冷却期跳过的日志噪音，改为“延后执行 + 最新覆盖”。
- 增加可观测指标：`sessionPendingSize`、`sessionQueueSize`。

阶段 2（中长期，1-2 周）：任务池/worker
- 引入任务队列，拆分为异步处理流程。

## 7. 配置建议（现阶段）

- 语句拆分桶：
  - 并发 = 1
  - 最小间隔 = 1500~3000ms
  - 冷却 = 5000~10000ms
- 分析桶：
  - 并发 = 1
  - 最小间隔 = 2000ms
- 通用请求：
  - 超时 = 30~60s（按模型 SLA 校准）
  - 重试 = 1~2 次（仅在非 4xx/429 时）

注：
- 以上参数以“追求稳定”为优先，后续结合 429 与 P95 延迟调整。

## 8. 可观测性与指标

建议记录：
- per bucket queue length / inFlight
- session pending size
- 429 频率与冷却时长
- GLM 请求耗时分布（P50/P95）

建议补充：
- per session end-to-end latency（拆分/分析）
- 入口丢弃率与覆盖率（最新任务覆盖比例）
- 幂等命中率（去重成功比例）

### 8.1 SLO 与告警

建议 SLO：
- 拆分/分析 P95 < 2x 基线
- 429 率 < 1%（峰值时段可放宽）

告警触发：
- 429 连续上升 + P95 抖动
- 入口丢弃率异常升高（可能参数过严）
- 队列堆积超过阈值（需扩容或降载）

## 9. 结论

当前多桶限流已具备基础能力，但在多会话并行场景下仍缺“会话公平 + 最新任务合并”。建议先落地方案一，再引入任务池/worker，逐步提升并发能力与稳定性。

## 10. 待确认事项（实施前）
- “最新任务”的判定字段（revisionId / windowEndTs）与过期阈值。
- 入口层幂等键规则与重复请求容忍度。
- 429 触发时的降载优先级（按任务类型还是按租户级）。
- 多实例部署下是否接受“单实例口径”的队列数展示；若不接受需聚合方案。

## 11. 链路同步检查（现状差异与风险）

- 双层排队：`GlmRateLimiter` 先走全局再走桶内，桶内排队期间占用全局并发，实际吞吐低于配置。
- 双重退避：分段/翻译/分析在 429 时 sleep + `GlmRateLimiter.onRateLimit` 并存，退避叠加、延迟放大。
- 重复限流：分段调度 `transcriptEventSegmentationGlobalInFlight` 与桶并发使用同一配置，等待中的任务也算 inFlight，吞吐下降。
- 内存增长：分段调度的 session 级 Map（latestRevision/lastRunAt 等）缺少清理策略，长期运行存在累积风险。
- 配置缺口：`TRANSCRIPT_EVENTS_SEGMENT_MAX_PENDING_SESSIONS`/`TRANSCRIPT_EVENTS_SEGMENT_MAX_STALENESS_MS` 未纳入配置；`GLM_TRANSCRIPT_SEGMENT_TRANSLATION_MODEL` 未暴露。
- 未实现：分析/翻译缺少会话级“最新任务覆盖”，旧任务可能长期占用桶队列。

## 12. AI 排队队列数展示方案（header-right）

目标：在前端 header-right 显示“AI 请求排队队列数”，口径可解释、性能可控。

### 12.1 发现的问题（按严重度）

- 高：双层排队结构下，若简单汇总 global + bucket，会出现重复统计或误导。
- 高：多实例部署时若仅统计单实例内存队列，前端显示会低估整体排队量。
- 中：受 `SettingsPasswordGuard` 保护时，普通用户无法读取队列数，需前端降级提示。
- 中：轮询频率过高会在多端同时在线时放大请求。

### 12.2 口径定义（KISS 版本）

- 队列数 = `global.queue + global.inFlight`（只统计全局桶，避免双层重复计数）。
- 不包含上游业务 pending（如语句拆分 pending），可作为扩展字段另行展示。
- 多实例下口径为“单实例队列数”，需在 tooltip 明确标注。

### 12.3 后端方案

- 在 `GlmRateLimiter` 增加 `getQueueStats()`：
  - 返回 `global` 与各桶 `{ queue, inFlight, blockedUntil }` 以及 `totalPending = global.queue + global.inFlight`。
- 暴露只读接口（建议挂在 `app-config` 下并复用 `SettingsPasswordGuard`）：
  - `GET /app-config/queue-stats` → `{ totalPending, buckets, instanceId }`
  - 接口应轻量、无数据库读写，仅内存统计。

### 12.4 前端方案

- 轻量轮询（2~3s）获取 `queue-stats`，header-right 显示 `totalPending`。
- Tooltip 说明口径：`queue + inFlight`、单实例统计、不含上游 pending。
- 未授权/失败时显示 `--` 并提示“未授权/不可用”。

### 12.5 风险与边界

- `totalPending` 不等于真实等待时间，需避免用户误解。
- 若后续实现 session 级公平队列，可将“业务 pending”作为扩展字段。
